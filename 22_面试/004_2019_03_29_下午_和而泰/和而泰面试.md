1. 前台还是别的  好像 很忙,写完很久了 匆匆来了一个面试官..

1. 问了 ArrayList, LinkedList 
2. 多线程,线程池
3. mysql 索引 和 组合索引
	1. MySQL中的索引的存储类型有两种：BTREE、HASH。 也就是用树或者Hash值来存储该字段
	2. 索引的分类
		　	MyISAM和InnoDB存储引擎：只支持BTREE索引， 也就是说默认使用BTREE，不能够更换
			MEMORY/HEAP存储引擎：支持HASH和BTREE索引
		* 单列索引
			* 普通索引	INDEX 			: MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。
			* 唯一索引	UNIQUE INDEX 	: 索引列中的值必须是唯一的，但是允许一个空值
			* 主键索引	PRIMARY KEY		: 一种特殊的唯一索引，不允许有空值
		* 组合索引	INDEX MultiIdx
			* 多个字段组合上创建的索引
			* 遵循最左前缀集合!
				* 最左边的列集来匹配行，这样的列集称为最左前缀
				* id，name，age	
					* (id，name，age)、(id，name)或者(id)  都会使用索引
					* （name，age）	不使用
		* 全文索引 　		FULLTEXT INDEX 
			* 只有在MyISAM引擎上才能使用
			* 只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引
			* 需要借助MATCH函数
			* 搜索的关键字默认至少要4个字符
			* 搜索的关键字太短就会被忽略掉


		* 空间索引
			* 必须使用MyISAM引擎
			* 空间类型的字段必须为非空
			* 空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有四种，GEOMETRY、POINT、LINESTRING、POLYGON
			
4. 集群定时任务,怎么解决重复问题
	1. Quartz的集群应用方式
		1. 如果你的项目使用的是Spring自带有Task定时任务机制，quartz框架本身就是支持集群环境，可以搭建集群环境下的定时器，也能解决上述问题 不过需要配置11张数据库表
	2. redis 过期机制和分布式锁
		1. Redis中定义一个键值对，可以用项目名称和服务器ip，执行任务前先从Redis中读取键，若没有值代表任务未被执行


5. mybatis 分页原理
6. sql  limit 100w,10  怎么优化	, limit [offset,] rows
	1.  * from table limit 0,10 这个没有问题 当 limit 200000,10 的时候数据读取就很慢
	2.  当一个数据库表过于庞大，LIMIT offset, length中的offset值过大，则SQL查询语句会非常缓慢，你需增加order by，并且order by字段需要建立索引
	3. 优化
		1. 子查询优化法
			1.  先找出第一条数据，然后大于等于这条数据的id就是要获取的数据
			2.  数据必须是连续的，可以说不能有where条件，where条件会筛选数据，导致数据失去连续性
   实验下
			select *
			from mytbl
			where id >=
			  (
			    select id
			    from mytbl
			    order by id
			    limit 100000,1
			  )

		2. 倒排表优化法
		   1. 倒排表法类似建立索引，用一张表来维护页数，然后通过高效的连接得到数据
  		   2. 缺点：只适合数据数固定的情况，数据不能删除，维护页表困难
		3. 反向查找优化法
			1. 当偏移超过一半记录数的时候，先用排序，这样偏移就反转了
			2. order by优化比较麻烦，要增加索引，索引影响数据的修改效率，并且要知道总记录数
   ，偏移大于数据的一半
		4. limit限制优化法
			1.  把limit偏移量限制低于某个数。。超过这个数等于没数据，我记得alibaba的dba说过他们是这样做的


7. redis 缓存
	https://baijiahao.baidu.com/s?id=1619572269435584821&wfr=spider&for=pc

	1. redis 缓存穿透
		1. 缓存穿透，是指查询一个数据库一定不存在的数据
		1. 流程
			* 参数传入对象主键ID
			* 根据key从缓存中获取对象
			* 如果对象不为空，直接返回
			* 如果对象为空，进行数据库查询
			* 如果从数据库查询出的对象不为空，则放入缓存（设定过期时间）
		2. 如果传入的参数为-1，会是怎么样？这个-1，就是一定不存在的对象,就会每次都去查询数据库，而每次查询都是空，每次又都不会进行缓存
			1. 假如有恶意攻击，就可以利用这个漏洞，对数据库造成压力，甚至压垮数据库。即便是采用UUID，也是很容易找到一个不存在的KEY，进行攻击。
		3. 数据库查询的空值也会,放入缓存,设定的缓存过期时间较短，比如设置为60秒。
	2. redis 缓存雪崩
		1. 缓存雪崩，是指在某一个时间段，缓存**集中**过期失效。
			1. 比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。
		2. 分散失效时间
	3. redis 缓存击穿
		1. 指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞
		2. 爆款
		3. 对主打商品都是早早的做好了准备，让缓存永不过期
8. token机制
